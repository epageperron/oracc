#!/usr/bin/perl
use warnings; use strict; use open 'utf8'; use utf8;
binmode STDIN, ':utf8'; binmode STDOUT, ':utf8'; binmode STDERR, ':utf8';

# This is the program that takes the history file resulting from glossary
# edits and applies it to the corpus.  It does so using the table of file:line
# locations and signatures, by editing the signatures according to the history
# file, generating a new instance lemmatization, and rewriting the occurrences
# of the new lemmatizations via the wid2loc table (actually generated by
# wid2lem).

###
### Exit status =
###	0 for changes applied successfully
###	1 for error
###	2 for no table needed
###

use lib "$ENV{'ORACC'}/lib";
use ORACC::CBD::History;
use ORACC::L2GLO::Util;
use ORACC::Texts::Util;

use Data::Dumper;

# get a hash of the changes made in the history file
my %h = history_map();
open(H,'>history.dump'); print H Dumper \%h; close(H);

# read the wid2lem data and determine which signatures change according
# to the history file; keep a list of changes to be made by file:line:wid
my %changes = ();
my %s = wid2lem_sigs('01bld/wid2lem.tab');
my @n = ();
foreach my $sig (keys %s) {
    my $n = '';
    my $e = '';
    my $s = '';

    my %p = parse_sig($sig);
    my $ocore = "$p{'cf'}\[$p{'gw'}\]$p{'pos'}";
    if ($h{$ocore}) {
	$e = $h{$ocore};
    }
    $ocore = "$p{'cf'}\[$p{'gw'}//$p{'sense'}\]$p{'pos'}'$p{'epos'}";
    if ($h{$ocore}) {
	$s = $h{$ocore};
    }
    if ($e && $s) {
	my %e = parse_sig($e);
	my %s = parse_sig($s);
	my $es = "$e{'cf'}\[$e{'gw'}//$s{'sense'}\]$e{'pos'}'$s{'pos'}";
	warn "merge $sig changes into $es\n";
	$changes{$sig} = $es;
    } elsif ($e) {
	warn "change $sig via entry $e\n";
	$e =~ s#\]#//$p{'sense'}]#;
	$changes{$sig} = $e;
    } elsif ($s) {
	warn "change $sig via sense $s\n";
	$changes{$sig} = $s;
    } else {
	# nothing to fix in this sig
    }
}

# generate the change list

open(C,'>changes.dump'); print C Dumper \%changes; close(C);
open(NOUT, "|err-sort.plx"); select NOUT;
if (scalar keys %changes > 0) {
    foreach my $c (keys %changes) {
	my @i = @{$s{$c}};
	foreach my $i (@i) {
	    my $new = '';
	    if (($new = has_changes($$i[1], $changes{$c}))) {
		my $loc = wid2lem_loc($$i[0]);
		print "$$loc[0]\:$$loc[1]:\t$$i[0]\t$$i[1]\t$new\t<<$changes{$c}\n";
	    }
	}
    }
} else {
    warn "$0: no 01bld/from-xtf.glo so no corpus fixes applied\n";
    exit 2;
}

########################################################################################

sub has_changes {
    my ($inst,$change) = @_;
    my $new = undef;
    my $ii = $inst; $ii =~ s/\].*$/]/; $ii =~ s/^\+//;
    my %i = parse_sig($ii);
    my %c = parse_sig($change);
    if ($c{'gw'} =~ /^c[vn][vn]e$/) {
	$new = "$c{'cf'}\[$c{'gw'}\]";
    } else {
	if ($c{'sense'}) {
	    $c{'sense'} =~ s/,\s.*$//;
	    $c{'sense'} =~ s/^a\s+//;
	    $c{'sense'} =~ s/^to\s+//;
	    $c{'sense'} =~ s/^\(to be\)\s+//;
	    $new = "$c{'cf'}\[$c{'sense'}\]";
	}
    }
    $new = undef if $ii eq $new;
    $new;
}

1;
